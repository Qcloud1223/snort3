#include <stdio.h>
#include <stdint.h>

#include "private_stack.h"
/* import top-level build options generated by cmake
 * Note: snort ignore all asserts when `--enable-debug` is disabled,
 * which is necessary for us -- a single check in context->start()
 * will fail, and there might be hundreds of similar checks ahead
 * However, snort is configured to only disable `NDEBUG` with this option,
 * so I have no choice but to move to `DEBUG_MSGS`,
 * which seems to only enable mere debug logs (Phew!)
 */
#include "config.h"
#include "detection/context_switcher.h"
#include "detection/ips_context.h"
#include "analyzer.h"

#define likely(x)       __builtin_expect(!!(x), 1)

RegSet DefaultStack;
void *StackTops[MAX_STACK_NUM];
int CurrStack = 0;
unsigned ReservedStacks = 0;

static int finished_idx = -1;
/* NB: all operation against this vector should be 64 bit */
static uint64_t finished_vector;
static bool all_stacks_initialized = false;
static uint64_t locked_vector;

static uint64_t finished_pkts;

/* hopefully switchers[-1] = main_switcher */
static ContextSwitcher *main_switcher;
static ContextSwitcher *switchers[MAX_STACK_NUM];

void init_stacks()
{
    size_t wholesize = MAX_STACK_NUM * MAX_STACK_SIZE;
    /* according to ABI, stack must be aligned to 16 bytes */
    void *allstacks = aligned_alloc(16, wholesize);
    /* since stack grow downwards, assign values to them reversely, too */
    for (int i = MAX_STACK_NUM - 1; i >= 0; i--) {
        allstacks = (void *)((size_t)allstacks + MAX_STACK_SIZE);
        StackTops[i] = allstacks;
    }
}

void init_switchers(void *cs_main)
{
    main_switcher = (ContextSwitcher *)cs_main;
    for (int i = 0; i < MAX_STACK_NUM; i++)
        switchers[i] = new ContextSwitcher;
    /* copy from: Analyzer::init_unprivileged() */
    const unsigned int max_contexts = 63;
    for (int i = 0; i < MAX_STACK_NUM; i++) {
        for (int j = 0; j < max_contexts; j++) {
            switchers[i]->push(new snort::IpsContext);
        }
    }
}

void set_private_switcher()
{
    Analyzer::set_switcher(switchers[CurrStack]);
}

void reserve_stacks(unsigned num)
{
    assert(num <= MAX_STACK_NUM);
    NumStacks = num;
    ReservedStacks = 0;
    finished_idx = -1;
    all_stacks_initialized = false;
    finished_vector = 0;
    locked_vector = 0;
}

/* NB: stack index can be negative! */
void stack_switch(int from, int to)
{
    RegSet *fromStack = from < 0 ? &DefaultStack : &CalleeRegs[from];
    RegSet *toStack   = to < 0 ? &DefaultStack : &CalleeRegs[to];
    /* manually set stack index (instead of self-inc) when switching */
    CurrStack = to;
    /* switch fake global variables */
    Analyzer::set_switcher(to < 0 ? main_switcher : switchers[to]);
    StackSwitchAsm(fromStack, toStack);
}

/* unlock stacks with policy to prevent dead locks
 * TODO: fine-grain unlocking policy
 */
void stack_unlock()
{
    if (locked_vector == 0)
        return;
    /* currently, unlocking stacks when the short path hitting the bottom */
    uint64_t unlock_state;
    /* TODO: in live capture mode, this likely might not hold */
    if (likely(ReservedStacks == 64))
        unlock_state = 0x5555555555555555;
    else {
        /* taking care of corner case where batch size != 64 */
        unlock_state = 0x5555555555555555 & ~(0xffffffffffffffff << ReservedStacks);
    }
    /* make sure at least all short paths are processed */
    if ((unlock_state & finished_vector) == unlock_state) {
#ifdef DEBUG_MSGS
        fprintf(stderr, "unlocking all stacks, finish vector: %lx\n", finished_vector);
#endif
        locked_vector = 0;
    }
}

/* find pending stack starting from the next, disabling jumping to itself when possible */
int get_unfinished_stack(int curr)
{
    assert(curr >= 0);
    for (auto i = 0; i < ReservedStacks; i++) {
        auto real_idx = ((curr + 1) + i) % ReservedStacks;
        /* find a stack not finished and not locked */
        if ((
                (finished_vector & ((uint64_t)1 << real_idx)) |
                (locked_vector & (uint64_t)1 << real_idx)
            ) == (uint64_t)0)
            return real_idx;
    }
    return -1;
}

/* Get the next stack with policy.
 * TODO: actually make the policy in user's code, by allowing defining a 
 * function to make the decision, based on the context
 */
/* TODO: a better name of this function should be `yield_control` */
void stack_next()
{
    /* if we reach the first private stack again, all the stacks are initialized */
    /* WARNING: this is still packet-based, not context-based! */
    if (ReservedStacks == NumStacks)
        all_stacks_initialized = true;
    /* first, create all the stacks by naively going back to main */
    if (all_stacks_initialized == false) {
        CurrStack++;
#ifdef DEBUG_MSGS
        fprintf(stderr, "[Init] Switching from %d to %d\n", CurrStack - 1, -1);
#endif
        stack_switch(CurrStack - 1, -1);
    }
    /* next, finish any unfinished stack */
    else {
        int to = get_unfinished_stack(CurrStack);
#ifdef DEBUG_MSGS
        fprintf(stderr, "[Fin] Switching from %d to %d\n", CurrStack, to);
#endif
        stack_switch(CurrStack, to);
    }
}

/* Mark a stack as end.
 * Ultimately, `analyzer` will have a `private_stack` member 
 */
void stack_end()
{
#ifdef DEBUG_MSGS
    fprintf(stderr, "Ending stack #%d\n", CurrStack);
#endif
    assert(CurrStack >= 0);
    finished_vector |= ((uint64_t)1 << CurrStack);
    finished_pkts++;
}

bool all_stacks_finished()
{
    /* Note that we cannot shift 64 bits */
    uint64_t fin_vec = (ReservedStacks == 0) ? 0 : ~(uint64_t)0 >> (64 - ReservedStacks);
#ifdef DEBUG_MSGS
    fprintf(stderr, "fin_vec: %lx, finish_vector: %lx\n", fin_vec, finished_vector);
#endif
    return (finished_vector == fin_vec);
}

bool stack_finished(int idx)
{
    return (finished_vector & ((uint64_t)1 << idx)) != 0;
}

/* return pending stack index if any, -1 if none */
int get_unfinished_stack()
{
    /* TODO: get unfinished with policy. Now is round-robin */
    uint8_t i;
    for (i = 0; i < ReservedStacks; i++) {
        if ((finished_vector & ((uint64_t)1 << i)) == (uint64_t)0) {
            // fprintf(stderr, "Find unfinished stack %d\n", i);
            return i;
        } 
    }
    return -1;
}

/* mark a stack as non-executable */
void stack_lock()
{
#ifdef DEBUG_MSGS
    fprintf(stderr, "Locking stack #%d\n", CurrStack);
#endif
    locked_vector |= (uint64_t)1 << CurrStack;
}